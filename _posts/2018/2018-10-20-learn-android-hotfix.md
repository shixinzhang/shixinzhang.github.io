---
layout: post
title: Android 热修复学习笔记
categories: Android
description: 
keywords: Android hotfix
---

记录学习 Android 热修复相关的收获。

# 哪些改动热修复没办法立即生效


**直接在运行期修改底层结构的热修复方案，只能支持方法/变量的替换、修改，无法支持方法/变量的增加和减少。**

因为方法的增加/减少，会导致类及 Dex 的方法数变化，从而导致方法索引变化，从而影响通过索引对方法的访问。

字段也是如此，影响字段索引。

>上面这说的是已有的类，新增的类不受限制。

概括的说，这两种情况无法使用热修复：

1. 修改会导致原有类的**结构变化**
2. 修复的非静态方法会被反射调用

以下情况的变动无法通过热修复解决，只能冷启动解决：

1. 匿名内部类的新增或者减少（导致生成的 ``OuterClass$N()`` 方法索引改变）无法热修复，除非是添加到外部类的最后，不影响其他匿名内部类 ``access$N()`` 方法的生成
2. 静态变量、静态代码块的变更（他们的初始化在``<clinit>`` 方法中，这个方法在类初始化时调用，不可改变）无法热修复
3. ``final static`` 引用类型的变量（还是在 ``<clinit>`` 中初始化）的修改 无法热修复，但是 ``final static`` 基本类型和 ``String`` 常量可以（他们不在``<clinit>`` 中初始化）
4. 已经被内联的方法，补丁里增加了对它的调用，不生效


内部类和外部类互相访问私有变量时，编译器会生成一个 ``access$N()`` 方法，这个方法的作用就是返回私有变量。如果修改了这些变量导致生成的  ``access$N()`` 方法索引改变，也有问题。

但这是可以解决的，可以通过修改自己和外部类变量的访问权限来避免生成 ``access$N()``。

> 方法内联 P47


# 参考文献

《深入探索 Android 热修复原理》