---
layout: post
title: IFE 基础学院 第七天到第八天：布局（定位、对齐、flexbox、响应式）
categories: FrontEnd
description: 学习笔记
keywords: 前端 笔记 布局 定位 响应式
---

学习目标：通过大量练习，来学习布局的各种方式。

[TOC]

[学习 CSS 布局](http://zh.learnlayout.com/toc.html)

# [第七天到第八天：学习布局](http://ife.baidu.com/course/detail/id/42)

# 日期，今天的学习总用时，今天学习的目标是什么，是否达成

- 2018.09.24 - 2018.10.10
- 零碎的几段时间，大概十几个小时吧


# 学习内容

- 定位
- 对齐
- Flexbox
- 左侧固定，右侧自适应
- 宽度自适应布局
- 圣杯布局

# 学习笔记

## 定位

- [MDN 定位](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/%E5%AE%9A%E4%BD%8D)
- [一篇不错的定位总结文章](http://www.cnblogs.com/chaixiaozhi/p/8481253.html)

>默认情况下，块级元素的内容宽度是其父元素的宽度的100％，并且与其内容一样高。
>
>内联元素高宽与他们的内容高宽一样。
>
>您不能对内联元素设置宽度或高度——它们只是位于块级元素的内容中。 
>
>如果要以这种方式控制内联元素的大小，则需要将其设置为类似块级元素 ``display: block``。

默认情况下，块级元素每个都单独一行，外边距会把块级元素分隔开。

如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫“外边距折叠”。

CSS 中使用 ``position`` 实现定位，可选的值：

1. ``static``，默认值，将元素放在前一个元素后面，没什么特别的
2. ``relative``，相对布局，相当于在静态布局的基础上增加了设置上下左右边距的功能
3. ``absolute``，绝对布局，不再存在于正常文档流
4. ``fixed``, 固定定位，相对于浏览器窗口
5. ``sticky``, 粘性定位

### relative 相对定位

relative 表现的和 static 一样，除非你添加了一些额外的属性(left right top bottom)。

> 在使用相对定位时，就算元素被偏移了，但是他仍然占据着它没偏移前的空间。

### absolute 绝对定位

绝对布局坐在它自己的层独立于一切。这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 。**例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的UI功能...**

绝对布局的 ``top`` ``bottom`` ``left`` ``right``指定的是**元素距离每个包含元素的边的距离，而不是指定元素应该移入的方向**，也就是说，到**包含元素**上下左右边框的距离，如果都设置为 0，那它可能会超出父布局的范围。

**【重要】⤵️**

如果想为元素设置层模型中的**绝对定位**，需要设置元素为 ``position:absolute``(表示绝对定位)，将元素从文档流中拖出来，然后使用left、right、top、bottom 属性相对于其最接近的一个具有定位属性（**position 值非 static**）的父包含块进行绝对定位。

如果不存在这样的包含块（就是它的祖先标签里并没有设置非 static 定位的属性），则相对于body元素，即相对于浏览器窗口。

> 默认情况下，绝对布局的包含元素是 ``body`` 元素。

我们可以通过给绝对布局的祖先元素设置定位来改变它的包含元素，祖先元素的 ``position`` 值为``relative`` 和 ``absolute`` 效果不一样，但一致的是，绝对布局元素会被限制在设置了定位的祖先元素范围内。

![](http://oqg4nua5z.bkt.clouddn.com/blog/0-position.jpg)

### fixed 固定定位

相对于浏览器窗口固定，可以用于创建固定的导航栏等。

>定位的内容不再出现在文档流中，所以其他内容会跑到它的下面，解决办法是设计外边距。

```
h1 {
	position: fixed;
	width: 500px;
	top: 0; 		//top:0 表示贴到顶部
	margin: 0 auto;
	background: #eeeeee;
	padding: 10px;
}
```

<div style="position: fixed;right: 0;bottom: 0; width: 100px;height: 100px;background-color: yellow;text-align: center;padding: 0">
	<p>广告位招租(•̀ᴗ•́)و</p>
</div>

### sticky 粘性定位

[MDN 粘性定位](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#Sticky_positioning)

粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。

### z-index（Z 轴层级）

>（0,0）位于页面（或元素）的左上角，x和y轴跨页面向右和向下，和安卓的一样。

``z-index`` 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。

默认情况下，定位的元素都具有 ``z-index`` 为 ``auto``，实际上为0。

> ``z-index`` 属性适用于定位元素（position 属性值为 relative 或 absolute 或 fixed 的对象），用来确定定位元素在垂直于显示屏方向（称为Z轴）上的层叠顺序。也就是说：**如果元素是没有定位的，对其设置的 z-index 会是无效的。**

如果父元素 z-index 失效（未定位或者使用默认值），那么定位子元素的 z-index 设置生效；否则子元素的 z-index 无效。

Z 轴层级小结：

1. ``z-index`` 只对定位元素有效
2. 父 ``z-index`` 有效子无效；父无效子有效
3. 都没有 ``z-index``，定位元素在上层
4. 都没有，且都定位，源代码中后面的在上层

## 定位实战

[MDN 定位实战](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Practical_positioning_examples)

>所谓的”单页应用“正在变得非常流行——尤其是移动网页UI——因为把一切的服务放在一个单独的文件上可以减少HTTP请求的数量来浏览所有内容，从而提高性能。

### 实战 1：切换 tab 效果

实现一个切换 tab 的思路：

1. 无序列表作为 tab，css 里设置不同状态下的样式、浮动
2. 用几个相同类型的布局 (``article``,``div``...)放置内容
3. 内容的父布局设置为相对布局 ``relative``，那样子布局就可以相对父布局放置，而不是默认的相对 body 放置
4. 内容布局设置为绝对布局 ``absolute``，左上角距离都是 0
5. 然后设置一个选中状态下的内容样式，``z-index`` 增加为 1，那样它就会显示到最上层
6. 最后在 js 中，在每个 tab 的点击事件里，移除所有旧 tab 的 class，给当前 tab 设置选中状态下的 class

```
<!DOCTYPE html>
<html>
<head>
	<title>定位实战</title>
	<link rel="stylesheet" type="text/css" href="css/day-7-layout-1.css">
	<script type="text/javascript">
		var tabs = document.querySelectorAll('.info-box li a');
		var panels = document.querySelectorAll('.info-box article');

		for (var i = 0; i < tabs.length; i++) {
			var tab = tabs[i];
			setClickHandler(tab, i);
		}

		function setClickHandler(tab, tabPos){
			tab.onclick = function () {
				alert('click' + tabPos);

				for(var i = 0; i < tabs.length; i ++ ){
					if (tabs[i].getAttribute('class')) {
						tabs[i].removeAttribute('class');
					}
				}

				tab.setAttribute('class', 'active');

				for(var i = 0; i < panels.length; i ++ ){
					if (panels[i].getAttribute('class')) {
						panels[i].removeAttribute('class');
					}
				}
				panels[tabPos].setAttribute('class', 'active-panel');
			}
		}
	</script>
</head>
<body>
<section class="info-box">
  <ul>
    <li><a href="#" class="active">Tab 1</a></li>
    <li><a href="#">Tab 2</a></li>
    <li><a href="#">Tab 3</a></li>
  </ul>
  <div class="panels">
    <article class="active-panel">
      <h2>The first tab</h2>

      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque turpis nibh, porttitor nec venenatis eu, pulvinar in augue. Vestibulum et orci scelerisque, vulputate tellus quis, lobortis dui. Vivamus varius libero at ipsum mattis efficitur ut nec nisl. Nullam eget tincidunt metus. Donec ultrices, urna maximus consequat aliquet, dui neque eleifend lorem, a auctor libero turpis at sem. Aliquam ut porttitor urna. Nulla facilisi.</p>
    </article>
    <article>
      <h2>The second tab</h2>

      <p>This tab hasn't got any Lorem Ipsum in it. But the content isn't very exciting all the same.</p>
    </article>
    <article>
      <h2>The third tab</h2>

      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque turpis nibh, porttitor nec venenatis eu, pulvinar in augue. And now an ordered list: how exciting!</p>

      <ol>
        <li>dui neque eleifend lorem, a auctor libero turpis at sem.</li>
        <li>Aliquam ut porttitor urna.</li>
        <li>Nulla facilisi</li>
      </ol>
    </article>
  </div>
</section>
</body>
</html>
```

### 实战 3：抽屉效果

```
<!DOCTYPE html>
<html>
<head>
	<title>定位实战3</title>
	<style type="text/css">
		label[for="toggle"] {
		  font-size: 3rem;
		  position: absolute;
		  top: 4px;
		  right: 5px;
		  z-index: 1;
		  cursor: pointer;
		}

		input[type="checkbox"] {
		  position: absolute;
		  top: -100px;
		}

		aside {
		  background-color: #a60000;
		  color: white;

		  width: 340px;
		  height: 98%;
		  padding: 10px 1%;

		  position: fixed;
		  top: 0;
		  right: -370px;

		/*在元素上设置 transition 属性，Transitions是一个有意思的特性，允许你在状态改变的时候平滑的过渡，而不是粗暴的“开”或“关”*/
		  transition: 0.6s all;
		}

		input[type=checkbox]:checked + aside {
		  right: 0px;
		}
	</style>
</head>
<body>
<label for="toggle">❔</label>
<input type="checkbox" id="toggle">
<aside>

  balabala

</aside>
</body>
</html>
```

> 在元素上设置 transition 属性，Transitions是一个有意思的特性，允许你在状态改变的时候平滑的过渡，而不是粗暴的“开”或“关”


实现抽屉效果思路：

1. 使用 ``label`` 标签，``for`` 值为我们给 ``checkbox`` 设置的 id，表示点击这个标签等于点击了这个开关
2. 将 label 放置在屏幕右侧，定位为绝对定位，``z-index`` 为 1，位于最上层
3. 将 checkbox 隐藏
4. 将要作为抽屉的布局设置为固定布局，那样将来页面滚动它也始终在同一位置，同时可以使用  ``top`` 和 ``right`` 控制它的位置
5. 给抽屉布局设置 ``transition`` 属性，允许布局状态改变时使用动画
6. 最后在 checkbox 被选中时，修改抽屉布局的 ``right`` 属性，即水平位置

## 居中对齐

[CSS布局(六) 对齐方式](http://www.cnblogs.com/chaixiaozhi/p/8490725.html)

- 水平居中
- 垂直居中
- 水平、垂直居中

主要分为行内元素和块状元素两种类型，另外元素的宽高是否确定也影响。

``text-align: center;`` 是让子元素水平对齐，名字有点误导人，不仅用于文字，别的元素也可以。


``vertical-align: middle`` 呢？感觉像是在父元素中垂直居中？

设置父容器的 ``font-size: 0`` 的作用：**消除 div 之间的空格，以实现准确地应用计算出来的宽度。**


## Flexbox 弹性盒子

[CSS 学习之 flexbox 入门](https://shixinzhang.top/2018/09/25/flexbox/)

## 响应式布局

- [媒体查询实现响应式布局的一个例子](http://zh.learnlayout.com/media-queries.html)
- [MDN 媒体查询](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries)
- [meta-viewport 导论](https://dev.opera.com/articles/an-introduction-to-meta-viewport-and-viewport/)

## 自适应布局

[七种实现左侧固定，右侧自适应两栏布局的方法](https://segmentfault.com/a/1190000010698609)

实现左侧固定、右侧自适应两栏布局的思路：

1. 利用 block 元素的宽度能随父容器调节的流动特性
2. 利用 CSS 中的 ``calc()`` 方法来动态设定宽度
3. 利用 CSS 中的新型布局 ``flex layout`` 与 ``grid layout``

**flex 可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。**

## 圣杯布局和双飞翼布局

- [CSS布局之--淘宝双飞翼布](http://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html)
- [圣杯布局](https://alistapart.com/article/holygrail)
- [双飞翼布局](http://www.imooc.com/wenda/detail/254035)

实现普通的三列布局比较简单，只要使用下面的布局，然后设置左浮动即可：

```
<div class="sub">子列</div>
<div class="main">主列</div>
<div class="extra">附加列</div>
```

这种结构的布局，浏览器在加载时的顺序：【子】、【主】、【附加】，如果要实现“重要的内容先加载”，就需要换一种布局和 CSS 实现。

![](https://upload-images.jianshu.io/upload_images/1747023-4b4ebc49181a2e4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

**圣杯/双飞翼布局主要解决俩问题：**

1. 三列布局，中间宽度自适应，两边定宽
2. 中间栏要在浏览器中优先展示渲染

首先实现三列布局（同时中间的布局先加载）比较简单，下面的布局，加上【浮动和负边距】，可以实现布局。

```
<div id="bd">
		<div class="main"></div>
		<div class="sub"></div>
		<div class="extra"></div>
	</div>
```

但存在的问题是，中间的内容会被左右覆盖一部分。

要调整中间的内容到合适位置，有两种实现思路：

1. 给父布局设置两侧 padding，然后给左右布局使用相对定位
2. 在中间内容中添加一层 div，给这个 div 设置外边距，这样就能保证实际的内容不会被覆盖
3. 直接给中间布局设置 ``box-sizing: border-box;`` 和 ``padding:0 190px 0 240px;``

思路 1 的实现代码：

```
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>双飞翼布局</title>
	<style type="text/css">
		* {
			box-sizing: border-box;
		}
		#bd {
			padding: 0 230px 0 190px;
			min-width: 610px;
		}
		.main {
			float: left;
			width: 100%;
			height: 500px;
			background: red;
		}
		.sub {
			float: left;
			width: 190px;
			height: 500px;
			/*浮动情况下，负边界值会导致DIV上移，而使用-100%可以确实它移动到最左侧*/
			margin-left: -100%;
			background: yellow;
			position: relative;
			left: -190px;
		}
		.extra {
			float: left;
			width: 230px;
			height: 500px;
			/*负左边界一定要大于或等于该DIV的宽度，才能靠到上一行去*/
			margin-left: -230px;
			background: blue;
			position: relative;
			right: -230px;
		}

	</style>
</head>
<body>
<div id="page">
	<div id="hd"></div>
	<div id="bd">
		<div class="main"></div>
		<div class="sub"></div>
		<div class="extra"></div>
	</div>
	<div id="ft"></div>
</div>
</body>
</html>
```

思路 2 的实现代码：

```
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>双飞翼布局</title>
	<style type="text/css">
		* {
			box-sizing: border-box;
		}
		#bd {
			/*padding: 0 230px 0 190px;*/
			min-width: 610px;
		}
		.main {
			float: left;
			width: 100%;
			height: 500px;
		}
		/*包裹的一层，设置左右外边距*/
		.main-wrap {
			margin-left: 200px;
			margin-right: 240px;
			background: grey;
			height: 500px;
		}
		.sub {
			float: left;
			width: 190px;
			height: 500px;
			/*浮动情况下，负边界值会导致DIV上移，而使用-100%可以确实它移动到最左侧*/
			margin-left: -100%;
			background: yellow;
			/*position: relative;
			left: -190px;*/
		}
		.extra {
			float: left;
			width: 230px;
			height: 500px;
			/*负左边界一定要大于或等于该DIV的宽度，才能靠到上一行去*/
			margin-left: -230px;
			background: blue;
			/*position: relative;
			right: -230px;*/
		}

	</style>
</head>
<body>
<div id="page">
	<div id="hd"></div>
	<div id="bd">
		<div class="main">
			<div class="main-wrap">
				我的主内容
			</div>
		</div>
		<div class="sub"></div>
		<div class="extra"></div>
	</div>
	<div id="ft"></div>
</div>
</body>
</html>
```

思路 3 实现：

```
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>双飞翼布局</title>
	<style type="text/css">
		* {
			/*box-sizing: border-box;*/
		}
		#bd {
			/*padding: 0 230px 0 190px;*/
			min-width: 610px;
		}
		.main {
			float: left;
			width: 100%;
			height: 500px;
			box-sizing: border-box;
			padding:0 190px 0 240px;
			background: red;
		}
		.sub {
			float: left;
			width: 190px;
			height: 500px;
			/*浮动情况下，负边界值会导致DIV上移，而使用-100%可以确实它移动到最左侧*/
			margin-left: -100%;
			background: yellow;
			/*position: relative;
			left: -190px;*/
		}
		.extra {
			float: left;
			width: 230px;
			height: 500px;
			/*负左边界一定要大于或等于该DIV的宽度，才能靠到上一行去*/
			margin-left: -230px;
			background: blue;
			/*position: relative;
			right: -230px;*/
		}

	</style>
</head>
<body>
<div id="page">
	<div id="hd"></div>
	<div id="bd">
		<div class="main">我的主内容</div>
		<div class="sub"></div>
		<div class="extra"></div>
	</div>
	<div id="ft"></div>
</div>
</body>
</html>
```

**可以看到，第一种思路纯使用 CSS 实现，CSS 略微复杂了一些；第二种思路 CSS 比较简单，但需要多增加一个标签。目前淘宝好像使用的是第二种思路。**

第三种是网友提出的，也很简单，缺点是左右布局底层其实是有中间布局的，只不过看不到。

> 如果把三栏布局比作一只大鸟，可以把main看成是鸟的身体，sub和extra则是鸟的翅膀。
> 
> 这个布局的实现思路是，先把最重要的身体部分放好，然后再将翅膀移动到适当的地方。因此请容许我给这个布局实现取名为**双飞翼布局（Flying Swing Layout）**.

上面的代码中，我们可以看到：需要设置其**左边距为负的中间盒子的宽度**，这样左盒子才可以往最左边移动。

浮动与负边距有什么不可告人的秘密呢？

答案是：**浮动情况下，（超过本身宽度的）负边界值会导致 DIV 上移，而使用 -100% 可以确使它移动到最左侧。**

>当你缩放页面的时候，宽度不能小于 700px，为了安全起见，最好还是给 body 加一个最小宽度!

# 回顾

请反复确认你是否掌握了以下概念：

1. 5 种定位方式及使用场景
2. 3 个定位例子
3. 弹性盒子的概念及使用场景

## 其他

>[CSS 框架](http://zh.learnlayout.com/frameworks.html)

``box-sizing`` 是个很新的属性，目前你还应该像我上面例子中那样使用 ``-webkit-`` 和 ``-moz-``m  前缀。

```
* {
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}
```

> 使用这些带前缀的，是为了兼容老版本或者不同浏览器。

**列表的子项 ``li`` 默认原来是 block 的，占一行；手动修改它为 inline-block 就可以让多行列表跑到一行了。**


也有 ``button``:

```
    <div>
      <button>Smile</button>
      <button>Laugh</button>
      <button>Wink</button>
      <button>Shrug</button>
      <button>Blush</button>
    </div>
```

## 问题

- ``display:table-cell`` 的意思？？
- 宽度使用 ``calc`` 计算不管用的原因？
- 绝对定位元素的盒模型特性??


下面的这个图片垂直居中实现的很奇怪，为什么设置行高，结合 ``vertical-align: middle`` 就能实现垂直居中了呢？不理解 - -。

```
		.center-img-parent {
			text-align: center;
			line-height: 140px;
			/*height: 140px;*/
			width: 400px;
			background: grey;
		}

		.center-img-child {
			width: 140px;
			height: 100px;
			vertical-align: middle;
		}
```

-------------
